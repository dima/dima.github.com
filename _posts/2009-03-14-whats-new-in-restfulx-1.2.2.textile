---
layout: post
title: What's New in RestfulX 1.2.2
---

h1. {{ page.title }}

p(meta). 14 March 2009 - Vancouver, BC

h1. Overview

Some of the key "themes" of this release are:

  1. *Distributed AIR apps* (Better push/pull workflow, out of the box distributed configuration for Rails back-end, etc)
  2. *schema_to_yaml integration* (helps with migrating existing Rails projects over to RestfulX)
  3. *More code generation options*

And of course bugfixing and a number of other features that we'll discuss further down.

h2. Distributed AIR apps/Synchronization

Distributed AIR apps and easier synchronization is one of the "key" themes in this release. 

You can generate distribution ready apps, pretty much out of the box. Here's a few steps to get you going:

{% highlight bash %}
$>rails foobar
$>cd foobar
$>vi config/environment.rb (add config.gem "restfulx" and config.gem "uuidtools")
$>./script/generate rx_config --distributed --air
$>create your db/model.yml file
$> rake db:refresh
$> rake rx:air:build
$> rake rx:air:run
{% endhighlight %}

You can perform both push and pull operations against a remote service provider.

{% highlight as3 %}
Rx.changes.push(); // Pushes changes from a local service provider to remote
Rx.changes.pull(); // Pulls data from a remote service provider to local
{% endhighlight %}

If you don't want to push/pull all the changes you can push and pull specific models only like so:

{% highlight as3 %}
Rx.changes.push(Project, Task);
Rx.changes.pull(Project);
{% endhighlight %}

Here's what a default distributed AIR app main application file looks like:

{% highlight as3 %}
<?xml version="1.0" encoding="utf-8"?>
<mx:WindowedApplication xmlns:mx="http://www.adobe.com/2006/mxml"
  xmlns:generated="foobar.components.generated.*"
  paddingBottom="8" paddingLeft="8" paddingRight="8" paddingTop="8"
  layout="horizontal" styleName="plain" initialize="init()">
  <mx:Script>
    <![CDATA[
      import air.net.SocketMonitor;
      import org.restfulx.events.PullEndEvent;
      import org.restfulx.events.PullStartEvent;
      import org.restfulx.events.PushEndEvent;
      import org.restfulx.events.PushStartEvent;
      import org.restfulx.controllers.ModelsController;
      import org.restfulx.controllers.ChangeController;
      import org.restfulx.services.ISyncingServiceProvider;
      import org.restfulx.services.http.XMLHTTPServiceProvider;
      import org.restfulx.services.air.AIRServiceProvider;
      import org.restfulx.Rx;
      import foobar.controllers.ApplicationController;
      
      [Bindable]
      private var socketMonitor:SocketMonitor;

      [Bindable]
      private var online:Boolean;
      
      [Bindable]
      private var syncStatus:String;

      private function init():void {
        Rx.enableLogging();
        Rx.httpRootUrl = "http://localhost:3000/";
        Rx.enableSync = true;
        //Rx.enableUndoRedo = true;

        socketMonitor = new SocketMonitor("localhost", 3000);
        socketMonitor.pollInterval = 2000; /* miliseconds */
        socketMonitor.addEventListener(StatusEvent.STATUS, onNetworkStatusChange);
        socketMonitor.start();
        
        ApplicationController.initialize([AIRServiceProvider], AIRServiceProvider.ID, "foobar");
        
        Rx.changes.setSyncProviders(
          ISyncingServiceProvider(Rx.services.getServiceProvider(AIRServiceProvider.ID)),
          Rx.services.getServiceProvider(XMLHTTPServiceProvider.ID));

        Rx.changes.addEventListener(PushStartEvent.ID, onPushStart);
        Rx.changes.addEventListener(PushEndEvent.ID, onPushEnd);
        Rx.changes.addEventListener(PullStartEvent.ID, onPullStart);
        Rx.changes.addEventListener(PullEndEvent.ID, onPullEnd);
      }
      
      private function onPushStart(event:Event):void {
        syncStatus = "Pushing changes ...";
      }
      
      private function onPushEnd(event:Event):void {
        syncStatus = "Push complete.";
      }
      
      private function onPullStart(event:Event):void {
        syncStatus = "Pulling data...";
      }
      
      private function onPullEnd(event:Event):void {
        syncStatus = "Pull complete.";
      }
      
      private function onNetworkStatusChange(event:StatusEvent):void {
        online = (socketMonitor.available) ? true : false;
  
        if (online) {
          Rx.defaultServiceId = XMLHTTPServiceProvider.ID;
        } else {
          Rx.defaultServiceId = AIRServiceProvider.ID;
        }
      }

      private function getCurrentProviderName(id:int):String {
        switch (id) {
          case XMLHTTPServiceProvider.ID:
            return "Rails";
          case AIRServiceProvider.ID:
            return "AIR (SQLite)";
          default :
            return "No idea";
        }
      }
    ]]>
  </mx:Script>
  <mx:VBox height="100%">
    <mx:Label text="Current Provider: {getCurrentProviderName(Rx.defaultServiceId)}"/>
    <mx:Label text="Network Status: {online ? 'Online' : 'Offline' }"/>
    <mx:HBox>
      <mx:Button label="Push" click="{Rx.changes.push()}" enabled="{online}"/>
      <mx:Button label="Pull" click="{Rx.changes.pull()}" enabled="{online}"/>
    </mx:HBox>
    <mx:Label text="{syncStatus}"/>
  </mx:VBox>
  <mx:LinkBar dataProvider="{mainViewStack}" direction="vertical" 
    borderStyle="solid" backgroundColor="#EEEEEE"/>
  <mx:ViewStack id="mainViewStack" width="100%" height="100%">
    <!-- For a simple demo, put all the components here. -->
    <generated:LocationBox/>
    <generated:NoteBox/>
    <generated:ProjectBox/>
    <generated:TaskBox/>
    <generated:UserBox/>
  </mx:ViewStack>
</mx:WindowedApplication>
{% endhighlight %}

h2. More code-generation options

Many thanks to Robert Malko for implementing much of this!

# You can now run and re-run *rx_yaml_scaffold* as many times as you like.
# You can also specify specific models to generate e.g. 
{% highlight bash %}
./script/generate rx_yaml_scaffold model1 model2
{% endhighlight %}
where model1 and model2 are defined in the db/model.yml file.

h2. More YAML configuration options for model.yml files

You can now use attachment_field as well as has_many_through keywords in your model.yml files. 

h2. Miscellaneous improvements

Chaining Rx.filter(Rx.sort()) is now actually functional.

You can now get easier access to AuxAIRController via XRx class, which serves a similar purpose to Rx. E.g.

{% highlight as3 %}
public function testFindAll():void {
  XRx.air(onFindAll).findAll(SimpleProperty, 
    ["name LIKE :name AND available = true", {":name": "%2%"}]);
}
{% endhighlight %}

You can now eager load nested relationships as well. Like so:
{% highlight as3 %}
public function testFindAllWithIncludes():void {
  XRx.air(onFindAllWithIncludes).findAll(Project, 
    ["name LIKE :name", {":name" : "%4%"}], ["tasks", "contractor"]);
}
{% endhighlight %}

You can now send custom HTTP headers with Rx.http() and XMLHTTPServiceProvider/JSONHTTPServiceProvider. Just set
Rx.customHTTPHeaders and off you go.

You can now use [HasMany(sort="foo:descending,caseInscensitive,numeric")] annotations, along these lines
 
{% highlight as3 %}
    [HasMany(sort="name:descending")]
    public var tasks:ModelsCollection;
{% endhighlight %}

And of course a bunch of bug fixes and other improvements.